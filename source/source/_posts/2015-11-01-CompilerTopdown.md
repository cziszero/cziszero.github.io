---
layout: post
title: 自顶向下的语法分析 LL(1)
description: 编译原理笔记之自顶向下分析
date: 2015-11-01
categories: 
  - 课程
  - 编译原理
tags:
  - 编译原理
---
## 基本概念

### 自顶向下的语法分析（Top-down Parsing）

*	从左到右对输入的终结符进行扫描.
*	对输入的语句寻找到一个最左推导.
*	对输入的语句自顶向下建立语法树模拟最左推导.
*	无回溯(Backtracking): 分析出错一定是输入的语句出错，而不是分析过程的推导出错.
*	预测分析法(predictive parser): 根据当前输入和当前需要展开的非终结符选择唯一的产生式.

### 预测分析法（Predictive Parser）###
#### 算法
1.	从左到右对输入的终结符扫描，句型的开始状态是文法开始符号和扫描的第一个终结符。
2.	根据当前的终结符a和当前句型的符号X，执行如下操作：
    if (X ∈ T and X == a) then读下个终结符; 
    句型取下一个符号；即match advanc
    else 分析出错。
    if (X /∈ T), 设A = X，
    选择唯一的一个产生式A →B, 该产生式满足：
    A ->B -*->ac,,将句型中的X 替换为B, 并且置当前句型的符号为B的第一个符号.
3.	重复上步直到状态句型中没有符号要处理并且当前输入
是文件结束标记.

#### 分类
递归下降分析法(Recursive descent parsing)，如: 
XL 语言；
LL(1) 分析法(表驱动)。

#### 共同点
共同特点: match() --- advance()，并且对文法有特定的要求.

#### 对文法的要求
产生式A → a1 | a2 | a3 ···· | an 只有唯一的一个能展开为a 的句型.

*	不能有相同的首符号，以消除根据终结符和非终结符来选择
产生式的二难，例如A → Aa|b,A 的两个产生式推出的
首符号都是b；A → aB | aC，A 的两个产生式推出的首符号
都是a，这两个产生式要消除。
*	消除左递归，以解决不知道推导深度的问题。消除方法：
A->Aa | b1 | b2 | ... | Bn,则可替换为A->bia*,i=1..n。[见课件P9]
*	消除间接左递归，通过非终结符号分层, 开始符号层次最高,
产生终结符的层次最低，低层不能产生高层非终结符，如果
产生则进行替换，替换为本层非终结符，从而把间接左递归
转化为直接左递归，然后依照上一条进行消除。
*	消除左公因子。第一点的更一般形式。若A->ab | ac | d
则等价为A->aA' | d; A'->b | c;进行消除。

## 递归下降分析方法
#### 原理
1.	每个非终结符对应于一个函数，
2.	每个终结符对应“match-advance”;
3.	每个函数翻译为其对应的产生式右边符号串对应的
调用序列;
4.	多个可选的产生式，用分支语句(“if”; “switch”);
5.	函数调用过程和非终结符展开过程一致，函数的递归
调用和语法树的前序遍历一致;

#### 特点
1.	程序简单
2.	递归调用增加内存开支
3.	适用较小规模的文法,如XL语言

## LL(1) 分析法(表驱动)

### 原理
原理与递归下降分析方法类似，只不过递归下降分析方法
是通过函数调用来表示产生式，而LL(1)是通过分析表来
存储和表示产生式。

### 分析表的构造
两种情况：**直接**，**间接**。
直接即通过生成式直接展开到终结符，间接即此非终结符
展开为空，下一非终结符展开到一个终结符。

### First集
**含义**：每个*语法符号串*所展开后第一个终结符可能是什么的
集合。递归定义见P27。
**求法**：先求文法层次较低非终结符，再求较高的，自底向上
继承来对应间接展开的问题。

### Follow集
**含义**：每个*非终结符*后面可能跟随什么终结符。递归定义
见P28。注意，Follow集最终不包含ε。
**求法**：先求文法层次较高非终结符，再求较低的，自顶向下
继承来对应间接展开的问题。

### select集合
**含义**：每个*产生式*最终展开后第一个终结符集合。
**求法**：见P29

### 分析表
根据select集合来填表。

注：在分析表中的出错栏上添加项目，将不会影响到分析器
的识别能力，但是将会影响到分析器报错的时间。

LL(1) 分析表中没有冲突项的文法称为LL(1) 文法, 该文法生
成的语言称为LL(1) 语言。LL(1) 文法一定是无二义性的文法
，二义文法也一定不是LL(1) 文法。

### 构成LL(1) 文法的条件
对文法的每个产生式 A → a | b有

*	a 和 b 没有左公因子
*	a 和 b 最多只有一个能推出ε
*	如果a=>ε, 则b的首符号一定不在Follow(A) 中

向前查看k个符号，且Select集不冲突的文法称为LL(k)文法;

**非LL语言**:
无论向前查看多少个符号k个符号都不能构造LL(k)文法;

### 出错处理
错误分为语法错误和语义错误。

Parser的任务是精确定位及恢复错误继续分析。

**同步符号的处理**：
a ∈ Follow(A) 称为A 的同步符号。
若栈顶为a，M[A][a] = err; a∈ Follow(A)，则弹出A，
因为漏掉A的成分是比较合理且可以继续分析的措施。

**非同步符号的处理**：
a /∈ Follow(A), 分析器恢复分析的动作是报错并跳过a, 
继续读下一个单词，直到出现分析表能够使分析器继续
动作的符号或同步符号。

### 小结
**LL(1) 分析表的构造步骤**

1.	文法转换：消除左递归和左公因子.
2.	对每个非终结符求First和Follow 集合.
3.	对每个产生式求Select 集合.
4.	对同一个非终结符的不同产生式查看Select 集合是否
有冲突.
5.	如果没有，填写分析表，注意文件结束标志$ 也是分
析表的一项.
6.	出错处理：同步符号.

**LL(1) 文法的特点**

*	直观，易于理解，实现容易，分析表体积小.
*	出错处理简单.
*	文法变换后破坏了原文法的完整性，不利于以后的语义分析. 但现代的LL 分析器自动生成工具使用Extended Backus-Naur Form, 这样消除左递归后不破坏语法结构的完整性. 如：exp → term(+term)*，因此LL 分析法也开始受到欢迎，如Princeton Univ. lcc就是用TopdownParser [ANTLR](http://www.cs.princeton.edu/software/lcc/),
也广泛使用.
*	不易于二义性的解消.
*	并不是所有无二义的上下文无关文法都有LL(k) 文法.


## 参考
大部分内容来自上课时老师的[课件](../docs/topdown.pdf)，仅作总结，如有侵权，告知即删。
