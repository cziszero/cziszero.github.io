---
layout: post
title: 自底向上的语法分析
description: 编译原理笔记之自底向上分析
date: 2015-11-04
categories: 
  - 课程
  - 编译原理
tags:
  - 编译原理
---
## Bottom-up Parsing的基本特点
*	从左到右对Input Terminal 扫描.
*	根据输入的Input 选择相应的产生式模拟最右推导的逆(也可看成自下而上建立语法树，由叶索根).
*	无回溯（Non-backtracking）
*	*归约(reduction)*是推导关系的逆，最左归约
是最右推导关系的逆。
## 最左规约的性质
*	被归约的对象一定是某一产生式RHS 的文法
符号串a，将a 看成是T ∪ N 为字母表的一个
正则表达式，b ∈ (T ∪ N)* 是要归约的对象，
则在b 中寻找a 子串可以用自动机解决.
*	被归约对象之后一定是终结符号串.
*	不确定性
*	正确的被归约的对象称为句柄(handle)，
即它能保证被归约后一定还保持着最右句型. 
例子:
1) exp PLUS term TIMES ID ⇐rm
exp PLUS term TIMES fac
2) exp PLUS term TIMES ID ⇐rm
exp PLUS exp TIMES ID
3) exp PLUS term TIMES ID ⇐rm
exp TIMES ID
只有(1) 是句柄.
如果文法是没有二义性的，则一个最右句型的
句柄是唯一的.
*	寻找句柄是解决自底向上分析的关键.
## 移进-规约（shift-reduce）分析器的设计
### 分析栈
保留已经归约的句型.
自左向右扫描.
"stack" + "rest of scan" = 最右句型.
句柄总是在栈顶形成.
无回溯.
### 问题.
*	在归约无误的前提下，句柄是否能保证总是在
栈顶形成.
*	如何不回看栈中元素，仅根据栈顶的状态和
当前的输入就能够正确地做出移进或归约的操作.
即如何保证规约无误。
*	对于问题一，有栈内的元素一定是已经归约到
不能再归约的对象，否则，由于可以规约，则在
新的移进前还要归约；句柄的最后一个文法符号
一定是栈顶元素。
*	对于问题二，如何判断句柄已经在栈顶形成
### 活前缀（viable prefix）.
语法树的垂直+水平遍历= 活前缀
## 自动机与活前缀
利用自动机记录语法树所有可能的``垂直+ 水平''遍历.

1.	用NFA 的状态记录语法树水平遍历的轨迹
2.	用树的结点作为NFA 的边
3.	用最右边的状态表示不能再水平遍历，是终止状态
4.	状态编号用LR(0) 项目表示
5.	父亲到最左儿子的垂直遍历用epsilon边连接

构造过程

1.	每个产生式对应于语法树可能的水平遍历，
为每个产生式构造DFA
2.	用epsilon连接产生式对应的NFA，对• 右边为
非终结符的状态用epsilon边连接该非终结符所有
的 DFA 的开始状态
3.	引入新的文法开始符号S'。
>
*拓广文法*: 
引入新的文法开始符号后的等价文法称为拓广文法，
该文法能保证新的开始符号永远不会出现在RHS中，
这样如果归约到该符号，并且输入结束就意味着
分析成功. 否则，由于原开始符号可能出现在句型
中，分析器在归约到该符号并面对输入结束时不能
正确地判断分析是否成功。

### 性质
*	活前缀是语法树由父亲到其最左儿子垂直向下
遍历或具有相同父亲结点从最左端开始自左向右
水平遍历所经过的节点序列，即最右推导。
*	自动机从开始状态出发的任何一条路经与上述
遍历一一对应，即某一文法符号串是活前缀，当且
仅当，它是自动机从开始状态到某一个或多个状态
所经历的边的序列，形成某一活前缀的所有可能的
最右推导与自动机在接受该活前缀后所到达的状态
集一致。
*	自动机从开始状态出发到达任何一个状态，其
状态对应的项目一定能最终形成句柄，该自动机
称为识别活前缀的自动机(简称前缀自动机).
*	有效项目集合= 自动机到达状态对应的项目集
### NFA到DFA 的直接转换
由生成式生成DFA，但生成式之间父子关系之间
添加的epslion边使之成为了NFA，因此需要将
NFA转为DFA。
主要为求epsilon-closure()的过程。与之前NFA转
DFA的算法差不多。
### 规范LR(0)项目集
识别活前缀DFA 中每状态对应的LR(0) 项目集称为
规范LR(0) 项目集。

在项目集中形如: A → B • a C 的项目称为移进
项目，该项目表示自动机在该状态下还没有形成
句柄，希望移进终结符a而形成句柄。

在项目集中形如A → a • C y 的项目称为goto
项目，该项目表示自动机在该状态下还没有形成
句柄，希望移进Cy 而形成句柄, 而非终结符C 不可
能通过移进得到，它只能是通过归约过程获得,因此
向下转移。

自动机的终止状态一定含有一个形如B → a• 的
项目，称为归约项目，如果自动机到达一个含有
归约项目的状态，表示该自动机最后所经历的
文法符号串一定是a，即句柄已经在活前缀中形成，
需要向上规约。

### 冲突
**两种冲突**

1.	如果在项目集中同时存在移进和归约项目，
称为移进- 归约(S-R) 冲突。
在该状态下，分析器可以移进终结符，也可以对
已经在分析栈中形成的句柄归约，从而导致分析
操作的不确定性。
2.	如果在项目集中同时存在两个不同的归约项目，
称为归约- 归约(R-R) 冲突。
在该状态下，分析栈中形成的两个句柄归约，分析器不知道
用哪一个对应的产生式归约，从而导致分析操作的不确定
性。

**解消冲突**
解消S-R冲突：根据当前输入的终结符号决定是否进行归约操作,进行归约
的必要条件是∃A → • ∈ I and a ∈ Follow(A),
否则，在归约后，由于可能没有含有Aa子串的句型，所以
分析器不可能再移进a而形成新的最右句型。

### 分析表的构造及分析动作

**分析栈**有两项内容: 识别活前缀自动机的状态和文法符号。
I0 是自动机的开始状态, 构成自动机的一个接受链。

**分析表**有两个: Action 表和Goto 表;
**Goto 表**记录归约为非终结符后，状态在接受该非终结
符后的转移情况，即是含有goto 项目在接受对应的非
终结符到达的状态：`goto [sn][A] = Dtrans(sn; A)`
**action 表** 对应分析栈栈顶状态面对当前输入进行的移进-归约
和状态转移操作，分为以下几种情况：

*	action[sn][ai] = shift sm (简记: ssm): 当
Dtrans(sn; ai) = sm; 对应的操作:ai，sm入栈。此时
action[sn][ai]的内容代表一个移进事件，如果硬要填上内容的话，
则应该填上移进之后的DFA的状态。
*	action[sn][ai] = reduce A → b (简记: rA → b ): 如果
ai ∈ Follow(A) and A → b• ∈ sn, 设|b| = k, 则分析操作: 
从分析栈中弹出k个元素, 设弹出元素之后的栈顶状态是Sm-k,
goto[sm􀀀-k][A] = sp。此时action[sn][ai]代表了一个规约事件，
并且需要记录用于规约的产生式（在看这里的时候看action表就是
因为这个没搞明白导致好长时间没看懂），如果硬要填上内容的话
应该填上文法产生式的代号。
*	action[sn][$] = accept, if S′ → S• ∈ sn。此时
action[sn][ai]表示成功事件。
*	action[sn][a] = error, 在其他情况下, 分析器报错。此时，
action[sn][ai]表示一个error事件。

## SLR 文法.
### SLR 分析表的构造
识别活前缀的自动机和规范LR(0) 项目集.
First 集和Follow 集.
构造Action 表和Goto 表，其中归约操作要看Follow 集.
### SLR 文法.
*	由上述方法构造的分析表如果没有S-R 和R-R 冲突，则称对应的
文法是SLR(1)（Simple LR(1)，简记SLR）文法.
*	一个由终结符号组成的符号串是SLR 文法的语句，当且仅当，该
串能被SLR 分析表对应的S-R 分析程序所接受.
*	一个SLR 文法一定是无二义的文法，因为无冲突的SLR 分析表保
证了最右推导的唯一性.
*	一个二义文法也一定不是SLR
*	LR 分析法更欢迎左递归(右增长) 文法, 它能保证移进的终
结符在最早的时间进行归约.
*	文法G是无二义文法，但是也有可能不是SLR 文法，可能存在S-R冲突，
因为Follow 集作为归约的条件不充分。
解决方法：将后随符号和最右句型联系起来，精确定位每个
项目的后随符号.
### LR(1)项目集的Dtrans.
LR(1)项目即一个二元组[LR(0) 项目, 终结符号或$]。
[A →  alpha • beta ; a]，[A → alpha • beta ; b]，可简记为：
[A →  alpha • beta ; a/b].
[A →  alpha • beta; a] 是一个对活前缀 Delta 有效LR(1)项目
iff:（1）. S ∗⇒gamma A w ⇒gamma alpha beta w;
（2）. delta = gamma alpha;
（3）. a ∈ First(w) or a = $, if w = epsilon;
### LR(1)项目集的epsilon-closure.
### 求解Dtrans(I,X)
## LR(1)文法
*	由上述方法构造的分析表如果没有S-R 和R-R 冲突，则称对应的
文法是LR(1)文法.
*	一个由终结符号组成的符号串是LR(1)文法的语句，当且仅当，该
串能被LR(1)分析表对应的S-R 分析程序所接受.
*	一个LR(1)文法一定是无二义的文法，因为无冲突的LR(1)分析表
保证了(最左归约) 最右推导的唯一性.
*	一个二义文法也一定不是LR(1)文法.
*	SLR 文法一定是LR(1)文法, 但是LR(1)文法不一定是SLR 文法,如
上例文法G 就不是SLR 文法,可以看出，SLR文法即Fellow集恰好等于
LR(1)项目第二分量的特殊情况。.
*	现有的程序设计语言一般都是LR(1)文法.
*	分析表太庞大，占用内存太大，如：C 语言的LR(1)分析表有几千
个状态和几百个文法符号.
